Ext.define('Ung.apps.intrusionprevention.MainController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.app-intrusion-prevention',

    control: {
        '#': {
            afterrender: 'getSettings',
        },
    },

    getSettings: function () {
        var me = this, v = this.getView(), vm = this.getViewModel();

        v.setLoading(true);

        vm.set('classtypes', Ext.create('Ext.data.ArrayStore', {
            fields: [ 'name', 'description', 'priority' ],
            sorters: [{
                property: 'name',
                direction: 'ASC'
            }],
            data: [
            [ "attempted-admin", "Attempted Administrator Privilege Gain".t(), "high"],
            [ "attempted-user", "Attempted User Privilege Gain".t(), "high" ],
            [ "inappropriate-content", "Inappropriate Content was Detected".t(), "high" ],
            [ "policy-violation", "Potential Corporate Privacy Violation".t(), "high" ],
            [ "shellcode-detect", "Executable code was detected".t(), "high" ],
            [ "successful-admin", "Successful Administrator Privilege Gain".t(), "high" ],
            [ "successful-user", "Successful User Privilege Gain".t(), "high" ],
            [ "trojan-activity", "A Network Trojan was detected".t(), "high" ],
            [ "unsuccessful-user", "Unsuccessful User Privilege Gain".t(), "high" ],
            [ "web-application-attack", "Web Application Attack".t(), "high" ],

            [ "attempted-dos", "Attempted Denial of Service".t(), "medium" ],
            [ "attempted-recon", "Attempted Information Leak".t(), "medium" ],
            [ "bad-unknown", "Potentially Bad Traffic".t(), "medium" ],
            [ "default-login-attempt", "Attempt to login by a default username and password".t(), "medium" ],
            [ "denial-of-service", "Detection of a Denial of Service Attack".t(), "medium" ],
            [ "misc-attack", "Misc Attack".t(), "medium" ],
            [ "non-standard-protocol", "Detection of a non-standard protocol or event".t(), "medium" ],
            [ "rpc-portmap-decode", "Decode of an RPC Query".t(), "medium" ],
            [ "successful-dos", "Denial of Service".t(), "medium" ],
            [ "successful-recon-largescale", "Large Scale Information Leak".t(), "medium" ],
            [ "successful-recon-limited", "Information Leak".t(), "medium" ],
            [ "suspicious-filename-detect", "A suspicious filename was detected".t(), "medium" ],
            [ "suspicious-login", "An attempted login using a suspicious username was detected".t(), "medium" ],
            [ "system-call-detect", "A system call was detected".t(), "medium" ],
            [ "unusual-client-port-connection", "A client was using an unusual port".t(), "medium" ],
            [ "web-application-activity", "Access to a potentially vulnerable web application".t(), "medium" ],

            [ "icmp-event", "Generic ICMP event".t(), "low" ],
            [ "misc-activity", "Misc activity".t(), "low" ],
            [ "network-scan", "Detection of a Network Scan".t(), "low" ],
            [ "not-suspicious", "Not Suspicious Traffic".t(), "low" ],
            [ "protocol-command-decode", "Generic Protocol Command Decode".t(), "low" ],
            [ "string-detect", "A suspicious string was detected".t(), "low" ],
            [ "unknown", "Unknown Traffic".t(), "low" ],

            [ "tcp-connection", "A TCP connection was detected".t(), "low" ]
            ]
        }));

        vm.set('categories', Ext.create('Ext.data.ArrayStore', {
            fields: [ 'name', 'description' ],
            sorters: [{
                property: 'name',
                direction: 'ASC'
            }],
            data: [
            ["app-detect", 'This category contains signatures that look for, and control, the traffic of certain applications that generate network activity. This category will be used to control various aspects of how an application behaves.'.t() ],
            ["activex", 'These are designed to catch exploits in the ActiveX framework.'.t() ],
            ["attack-response", 'These are designed to catch the results of a successful attack. Things like \'id=root\', or error messages that indicate a compromise may have happened. Note: Trojan and virus post-infection activity is included generally in the VIRUS signature set, not here.'.t() ],
            ["blacklist", 'This category contains URI, USER-AGENT, DNS, and IP address signatures that have been determined to be indicators of malicious activity. These signatures are based on activity from the Talos virus sandboxes, public list of malicious URLs, and other data sources.'.t() ],
            ["botcc", 'These are autogenerated from several sources of known and confirmed active Botnet and other Command and Control hosts. Updated daily, primary data source is Shadowserver.org.' .t() ],
            ["browser-chrome", 'This category contains detection for vulnerabilities present in the Chrome browser. (This is separate from the browser-webkit category, as Chrome has enough vulnerabilities to be broken out into it\'s own, and while it uses the Webkit rendering engine, there\'s a lot of other features to Chrome.)'.t() ],
            ["browser-firefox", 'This category contains detection for vulnerabilities present in the Firefox browser, or products that have the Gecko engine. (Thunderbird email client, etc)'.t() ],
            ["browser-ie", 'This category contains detection for vulnerabilities present in the Internet Explorer browser (Trident or Tasman engines)'.t() ],
            ["browser-webkit", 'This category contains detection of vulnerabilities present in the Webkit browser engine (aside from Chrome) this includes Apple\'s Safari, RIM\'s mobile browser, Nokia, KDE, Webkit itself, and Palm.'.t() ],
            ["browser-other", 'This category contains detection for vulnerabilities in other browsers not listed above.'.t() ],
            ["browser-plugins", 'This category contains detection for vulnerabilities in browsers that deal with plugins to the browser. (Example: Active-x)'.t() ],
            ["chat", 'These are designed to catch exploits from various chat applications.'.t() ],
            ["ciarmy", 'These are designed to catch exploits identified by Collective Intellegence Network Security.'.t() ],
            ["community", 'General community shared signatures.'.t() ],
            ["compromised", 'Signatures to block known hostile or compromised hosts.'.t() ],
            ["content-replace", 'This category contains any signature that utilizes the replace functionality inside of Snort.'.t() ],
            ["current-events", 'Signatures identified by various alert agencies.'.t() ],
            ["data", 'Sensitive data such as credit cards, social security numbers, etc.'.t() ],
            ["decoder", 'Detect various TCP/UDP/IP level protocol anomolies that typically indicate exploit attempts.'.t() ],
            ["deleted", 'When a signature has been deprecated or replaced it is moved to this categories. Signatures are never totally removed from the signature set, they are moved here.'.t() ],
            ["dns", 'This category is for signatures that may indicate the presence of the DNS protocol or vulnerabilities in the DNS protocol on the network.'.t() ],
            ["dos", 'Intended to catch inbound DOS activity, and outbound indications.'.t() ],
            ["drop", 'This is a daily updated list of the Spamhaus DROP (Don\'t Route or Peer) list. Primarily known professional spammers.'.t() ],
            ["dshield", 'Daily updated list of the DShield top attackers list.'.t() ],
            ["exploit", 'This is an older category which will be deprecated soon. This category looks for exploits against software in a generic form.'.t() ],
            ["exploit-kit", 'This category contains signatures that are specifically tailored to detect exploit kit activity. This does not include post-compromise signatures (as those would be in indicator-compromise). Files that are dropped as result of visiting an exploit kit would be in their respective file category.'.t() ],
            ["file-executable", 'This category contains signatures for vulnerabilities that are found or are delivered through executable files, regardless of platform.'.t() ],
            ["file-flash", 'This category contains signatures for vulnerabilities that are found or are delivered through flash files. Either compressed or uncompressed, regardless of delivery method platform being attacked.'.t() ],
            ["file-image", 'This category contains signatures for vulnerabilities that are found inside of images files. Regardless of delivery method, software being attacked, or type of image. (Examples include: jpg, png, gif, bmp, etc)'.t() ],
            ["file-identify", 'This category is to identify files through file extension, the content in the file (file magic), or header found in the traffic. This information is usually used to then set a flowbit to be used in a different signature.'.t() ],
            ["file-multimedia", 'This category contains signatures for vulnerabilities present inside of multimedia files (mp3, movies, wmv)'.t() ],
            ["file-office", 'This category contains signatures for vulnerabilities present inside of files belonging to the Microsoft Office suite of software. (Excel, PowerPoint, Word, Visio, Access, Outlook, etc)'.t() ],
            ["file-pdf", 'This category contains signatures for vulnerabilities found inside of PDF files. Regardless of method of creation, delivery method, or which piece of software the PDF affects (for example, both Adobe Reader and FoxIt Reader)'.t() ],
            ["file-other", 'This category contains signatures for vulnerabilities present inside a file, that doesn\'t fit into the other categories above.'.t() ],
            ["ftp", 'This category is for signatures that may indicate the presence of the ftp protocol or vulnerabilities in the ftp protocol on the network.'.t() ],
            ["games", 'This category is for signatures that may indicate the presence of gaming protocols or vulnerabilities in the gaming protocols on the network.'.t() ],
            ["icmp", 'This category is for signatures that may indicate the presence of icmp traffic or vulnerabilities in icmp on the network.'.t() ],
            ["icmp-info", 'Attempts to determine target hardware and software using typical ICMP behavior.'.t() ],
            ["imap", 'This category is for signatures that may indicate the presence of the imap protocol or vulnerabilities in the imap protocol on the network.'.t() ],
            ["inappropriate", 'Porn, Kiddy porn, sites you shouldn\'t visit at work, etc. Warning: These are generally quite Regex heavy and thus high load and frequent false positives. Only run these if you\'re really interested.'.t() ],
            ["indicator-compromise", 'This category contains signatures that are clearly to be used only for the detection of a positively compromised system, false positives may occur.'.t() ],
            ["indicator-obfuscation", 'This category contains signatures that are clearly used only for the detection of obfuscated content. Like encoded JavaScript signatures.'.t() ],
            ["indicator-shellcode", 'This category contains signatures that are simply looking for simple identification markers of shellcode in traffic. This replaces the old shellcode.signatures.'.t() ],
            ["info", 'Signatures that attempt to send informaton to commonly known malware sites.'.t() ],
            ["malware-backdoor", 'This category contains signatures for the detection of traffic destined to known listening backdoor command channels. If a piece of malicious soft are opens a port and waits for incoming commands for its control functions, this type of detection will be here. A simple example would be the detection for BackOrifice as it listens on a specific port and then executes the commands sent.'.t() ],
            ["malware-cnc", 'This category contains known malicious command and control activity for identified botnet traffic. This includes call home, downloading of dropped files, and ex-filtration of data. Actual commands issued from Master to Zombie type stuff will also be here.'.t() ],
            ["malware-tools", 'This category contains signatures that deal with tools that can be considered malicious in nature. For example, LOIC.'.t() ],
            ["malware-other", 'This category contains signatures that are malware related, but don\'t fit into one of the other malware categories.'.t() ],
            ["misc", 'Various, otherwise uncategorizable exploit attempts.'.t() ],
            ["mobile-malware", 'This category contains signatures for the detection of traffic on mobile devices.'.t() ],
            ["netbios", 'This category is for signatures that may indicate the presence of NetBIOS traffic or vulnerabilities in NetBIOS on the network.'.t() ],
            ["os-linux", 'This category contains signatures that are looking for vulnerabilities in Linux based OSes. Not for browsers or any other software on it, but simply against the OS itself.'.t() ],
            ["os-solaris", 'This category contains signatures that are looking for vulnerabilities in Solaris based OSes. Not for any browsers or any other software on top of the OS.'.t() ],
            ["os-windows", 'This category contains signatures that are looking for vulnerabilities in Windows based OSes. Not for any browsers or any other software on top of the OS.'.t() ],
            ["os-other", 'This category contains signatures that are looking for vulnerabilities in an OS that is not listed above.'.t() ],
            ["p2p", 'This category deals with pua or Potentially Unwanted Applications that deal with p2p.'.t() ],
            ["pop3", 'This category is for signatures that may indicate the presence of the pop3 protocol or vulnerabilities in the pop3 protocol on the network.'.t() ],
            ["preprocessor_portscan", 'This category contains signatures that are looking for vulnerabilities via portscans.'.t() ],
            ["policy-multimedia", 'This category contains signatures that detect potential violations of policy for multimedia. Examples like the detection of the use of iTunes on the network. This is not for vulnerabilities found within multimedia files, as that would be in file-multimedia.'.t() ],
            ["policy-social", 'This category contains signatures for the detection potential violations of policy on corporate networks for the use of social media. (p2p, chat, etc)'.t() ],
            ["policy-other", 'This category is for signatures that may violate the end-users corporate policy bud do not fall into any of the other policy categories first.'.t() ],
            ["policy-spam", 'This category is for signatures that may indicate the presence of spam on the network.'.t() ],
            ["protocol-finger", 'This category is for signatures that may indicate the presence of the finger protocol or vulnerabilities in the finger protocol on the network.'.t() ],
            ["protocol-ftp", 'This category is for signatures that may indicate the presence of the ftp protocol or vulnerabilities in the ftp protocol on the network.'.t() ],
            ["protocol-icmp", 'This category is for signatures that may indicate the presence of icmp traffic or vulnerabilities in icmp on the network.'.t() ],
            ["protocol-imap", 'This category is for signatures that may indicate the presence of the imap protocol or vulnerabilities in the imap protocol on the network.'.t() ],
            ["protocol-pop", 'This category is for signatures that may indicate the presence of the pop protocol or vulnerabilities in the pop protocol on the network.'.t() ],
            ["protocol-services", 'This category is for signatures that may indicate the presence of the rservices protocol or vulnerabilities in the rservices protocols on the network.'.t() ],
            ["protocol-voip", 'This category is for signatures that may indicate the presence of voip services or vulnerabilities in the voip protocol on the network.'.t() ],
            ["pua-adware", 'This category deals with pua or Potentially Unwanted Applications that deal with adware or spyware.'.t() ],
            ["pua-p2p", 'This category deals with pua or Potentially Unwanted Applications that deal with p2p.'.t() ],
            ["pua-toolbars", 'This category deals with pua or Potentially Unwanted Applications that deal with toolbars installed on the client system. (Google Toolbar, Yahoo Toolbar, Hotbar, etc)'.t() ],
            ["pua-other", 'This category deals with pua or Potentially Unwanted Applications that don\'t fit into one of the categories shown above.'.t() ],
            ["rpc", 'Remote Proceudre Call exploits.'.t() ],
            ["scada", 'SCADA sourced exploits.'.t() ],
            ["scan", 'Scanning exploits.'.t() ],
            ["server-apache", 'This category deals with vulnerabilities in or attacks against the Apache Web Server.'.t() ],
            ["server-iis", 'This category deals with vulnerabilities in or attacks against the Microsoft IIS Web server.'.t() ],
            ["server-mssql", 'This category deals with vulnerabilities in or attacks against the Microsoft SQL Server.'.t() ],
            ["server-mysql", 'This category deals with vulnerabilities in or attacks against Oracle\'s MySQL server.'.t() ],
            ["server-oracle", 'This category deals with vulnerabilities in or attacks against Oracle\'s Oracle DB Server.'.t() ],
            ["server-webapp", 'This category deals with vulnerabilities in or attacks against Web based applications on servers.'.t() ],
            ["server-mail", 'This category contains signatures that detect vulnerabilities in mail servers. (Exchange, Courier). These are separate from the protocol categories, as those deal with the traffic going to the mail servers itself.'.t() ],
            ["server-other", 'This category contains signatures that detect vulnerabilities in or attacks against servers that are not detailed in the above list.'.t() ],
            ["shellcode", 'Exploits that attempt to excute shell commands on various operating systems.'.t() ],
            ["smtp", 'This category is for signatures that may indicate the presence of the SMTP protocol or vulnerabilities in the SMTP protocol on the network.'.t() ],
            ["snmp", 'This category is for signatures that may indicate the presence of the SNMP protocol or vulnerabilities in the SNMP protocol on the network.'.t() ],
            ["sql", 'SQL exploits.'.t() ],
            ["tftp", 'This category is for signatures that may indicate the presence of the TFTP protocol or vulnerabilities in the TFTP protocol on the network.'.t() ],
            ["tor", 'TOR exploits.'.t() ],
            ["trojan", 'Trojan Horse exploits.'.t() ],
            ["user-agents", 'This category deals with vulnerabilities in or attacks against common application clients.'.t() ],
            ["voip", 'This category deals with vulnerabilities in or attacks against Voice Over IP applications.'.t() ],
            ["web-client", 'This category deals with vulnerabilities in or attacks against Web clients.'.t() ],
            ["web-server", 'This category deals with vulnerabilities in or attacks against Web servers.'.t() ],
            ["web-specific-apps", 'This category deals with vulnerabilities in or attacks against Web based applications on servers.'.t() ],
            ["worm", 'Worm exploits.'.t() ],
            ]
        }));

        Ext.Deferred.sequence([
            Rpc.asyncPromise(v.appManager, 'getLastUpdateCheck'),
            Rpc.asyncPromise(v.appManager, 'getLastUpdate'),
            Rpc.directPromise('rpc.companyName'),
            function(){ return Ext.Ajax.request({
                url: "/admin/download",
                method: 'POST',
                params: {
                    type: "IntrusionPreventionSettings",
                    arg1: "load",
                    arg2: vm.get('instance.id')
                },
                timeout: 600000});
            },function(){ return Ext.Ajax.request({
                url: "/admin/download",
                method: 'POST',
                params: {
                    type: "IntrusionPreventionSettings",
                    arg1: "wizard",
                    arg2: vm.get('instance.id')
                },
                timeout: 600000});
        }]).then(function(result){
            if(Util.isDestroyed(me, vm)){
                return;
            }
            var settings = null;
            try{
                settings = Ext.decode( result[3].responseText);
            }catch(error){
                v.setLoading(false);
                Util.handleException({
                    message: 'Intrusion Prevention settings file is corrupt.'.t()
                });
                return;
            }
            vm.set({
                lastUpdateCheck: (result[0] !== null && result[0].time !== 0 ) ? Renderer.timestamp(result[0]) : "Never".t(),
                lastUpdate: (result[1] !== null && result[1].time !== 0 ) ? Renderer.timestamp(result[1]) : "Never".t(),
                companyName: result[2],
                settings: settings,
                wizardDefaults: Ext.decode( result[4].responseText ),
                profileStoreLoad: true,
                signaturesStoreLoad: true,
                variablesStoreLoad: true
            });
            v.getController().updateStatus();
            vm.set('panel.saveDisabled', false);
            v.setLoading(false);

        }, function (ex) {
            if(!Util.isDestroyed(me, v )){
                vm.set('panel.saveDisabled', true);
                v.setLoading(false);
            }
            Util.handleException(ex);
        });
    },

    getChangedDataRecords: function(target){
        var v = this.getView();
        var changed = {};
        v.query('app-intrusion-prevention-' + target).forEach(function(grid){
            var store = grid.getStore();
            store.getModifiedRecords().forEach( function(record){
                var data = {
                    op: 'modified',
                    recData: record.data
                };
                if(record.get('markedForDelete')){
                    data.op = 'deleted';
                }else if(record.get('markedForNew')){
                    data.op = 'added';
                }
                changed[record.get('_id')] = data;
            });
            store.commitChanges();
        });

        return changed;
    },

    getChangedData: function(){
        var me = this, vm = this.getViewModel();

        var settings = vm.get('settings');
        var changedDataSet = {};
        var keys = Object.keys(settings);
        for( var i = 0; i < keys.length; i++){
            if( ( keys[i] == "signatures" ) ||
                ( keys[i] == "variables" ) ||
                ( keys[i] == "profileId" ) ||
                ( keys[i] == "activeGroups") ){
                continue;
            }
            changedDataSet[keys[i]] = settings[keys[i]];
        }

        changedDataSet.signatures = me.getChangedDataRecords('signatures');
        changedDataSet.variables = me.getChangedDataRecords('variables');

        return changedDataSet;
    },

    setSettings: function (additionalChanged) {
        var me = this, v = this.getView(), vm = this.getViewModel();

        if (!Util.validateForms(v)) {
            return;
        }

        v.setLoading(true);

        var changedData = me.getChangedData();
        if(arguments.length == 1){
            if(additionalChanged){
                changedData= Ext.Object.merge(changedData,additionalChanged);
            }
        }

        Ext.Ajax.request({
            url: "/admin/download",
            jsonData: changedData,
            method: 'POST',
            params: {
                type: "IntrusionPreventionSettings",
                arg1: "save",
                arg2: vm.get('instance.id')
            },
            scope: this,
            timeout: 600000
        }).then(function(result){
            if(Util.isDestroyed(me, v, vm)){
                return;
            }

            var response = Ext.decode( result.responseText );
            vm.set({
                profileStoreLoad: true,
                signaturesStoreLoad: true,
                variablesStoreLoad: true
            });

            if( !response.success) {
                Ext.MessageBox.alert("Error".t(), "Unable to save settings".t());
            } else {
                Rpc.asyncData(v.appManager, 'reconfigure')
                .then( function(result){
                    if(Util.isDestroyed(me, v, vm)){
                        return;
                    }
                    v.setLoading(false);
                    Util.successToast('Settings saved...');
                    v.down('appstate').getController().reload();
                    me.getSettings();
                    Ext.fireEvent('resetfields', v);
                }, function(result){
                    if(!Util.isDestroyed(me, v, vm)){
                        v.setLoading(false);
                        vm.set('panel.saveDisabled', true);
                    }
                    Util.handleException(ex);
                });
            }
        }, function(response){
            Ext.MessageBox.alert("Error".t(), "Unable to save settings".t());
            if(!Util.isDestroyed(me, v, vm)){
                v.setLoading(false);
                Util.successToast('Unable to save settings...');
                return;
            }
            Util.handleException(response);
        });

    },

    regexSignatureVariable :  /^\$([A-Za-z0-9\_]+)/,
    regexSignature: /^([#]+|)(alert|log|pass|activate|dynamic|drop|sdrop|reject)\s+(tcp|udp|icmp|ip)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+\((.+)\)$/,
    isVariableUsed: function(variable) {
        var me = this, vm = this.getViewModel();

        if(Ext.isEmpty(variable)) {
            return false;
        }

        var signature, originalId, signatureMatches, variableMatches, j, internalId, d;
        var isUsed = false;
        vm.get('signatures').each(function(record){
            var signatureMatches = me.regexSignature.exec( record.get('signature') );
            if( signatureMatches ) {
                for( j = 1; j < signatureMatches.length; j++ ) {
                    variableMatches = me.regexSignatureVariable.exec( signatureMatches[j] );
                    if( variableMatches && variableMatches.shift().indexOf(variable)!= -1) {
                        isUsed = true;
                        return false;
                    }
                }
            }

        });
        return isUsed;
    },

    runWizard: function (btn) {
        this.wizard = this.getView().add({
            xtype: 'app-intrusion-prevention-wizard'
        });
        this.wizard.show();
    },

    storeDataChanged: function( store ){
        /*
         * Inexplicably, extjs does not see 'inline' data loads as "proper" store
         * reloads so it will never fire the 'load' event which logically sounds
         * like the correct event to listen to.
         *
         * The problem occurs on saves where data is "reloaded" but seen in
         * the store as a wholesale change.  Which is ridiculous and on the next
         * save in the same session, causes to see all records as modified
         * and therefore, send send ALL data back.
         *
         * To get around this, we have the inline loader routines set the
         * 'storeId'Load variable and if we see it here, cause all of those changes
         * to be "commited" since nothing has changed.
         *
         * Thanks, ExtJs.
         *
         */
        var vm = this.getViewModel();
        var storeId = store.getStoreId();
        if(vm.get( storeId + 'Load') == true){
            store.commitChanges();
            vm.set( storeId + 'Load', false);
        }
    },

    /*
     * Update bind variables for the Setup Wizard display on status screen.
     * On first blush we could do these as formulas but the code is basically the
     * same and would be duplicated.  So we do it here after the data has been
     * loaded.
     */
    updateStatus: function(){
        var me = this, vm = me.getViewModel();
        var activeGroups = vm.get('settings.activeGroups');
        var profileId= vm.get('settings.profileId');

        var types = ['classtypes', 'categories'];
        types.forEach(function(type){
            var current = activeGroups[type];
            var profile = {};

            var rawSelected = null;
            if(current === 'custom'){
                rawSelected = Ext.clone(activeGroups[type+'Selected']);
            }else{
                vm.get('wizardDefaults').profiles.forEach(function(wizardProfile){
                    if(wizardProfile.profileId === profileId){
                        rawSelected = Ext.clone( wizardProfile.activeGroups[type+'Selected'] );
                    }
                });
            }

            var selected = [];
            rawSelected.forEach(function(item){
                if(item[0] === '-'){
                    return;
                }
                if(item[0] === '+'){
                    item = item.substring(1);
                }
                selected.push(item);
            });
            profile.selected = selected;

            if(current === 'custom'){
                profile.value = 'Custom'.t() + Ext.String.format( ': {0}', selected.join(', ') );
            }else{
                profile.value = 'Recommended'.t();
            }
            profile.tip = selected.join(', ');
            vm.set(type+'Profile', profile);
        });
    },

    /**
     * ExtJs does not seem to allow tooltip binding, so to get around this, create
     * model variable with 'value' and 'tip' keys and when the value changes,
     * look at the bind parent value for that object and set the tooltip.
     */
    bindChange: function(cmp){
        cmp.getEl().set({
            'data-qtip': cmp.bind.value.stub.parentValue.tip
        });
    }

});

Ext.define('Ung.apps.intrusionprevention.cmp.SignaturesRecordEditor', {
    extend: 'Ung.cmp.RecordEditor',
    xtype: 'ung.cmp.unintrusionsignaturesrecordeditor',

    controller: 'unintrusionsignaturesrecordeditorcontroller',
});

Ext.define('Ung.apps.intrusionprevention.cmp.SignaturesRecordEditorController', {
    extend: 'Ung.cmp.RecordEditorController',
    alias: 'controller.unintrusionsignaturesrecordeditorcontroller',

    editorClasstypeChange: function( me, newValue, oldValue, eOpts ){
        var vm = this.getViewModel();
        if( newValue == null || vm.get('classtypes').findExact('name', newValue) == null ){
            me.setValidation("Unknown classtype".t());
            return false;
        }
        me.setValidation(true);

        this.getView().up('grid').getController().updateSignature( this.getViewModel().get('record'), 'classtype', newValue );
    },

    editorMsgChange: function( me, newValue, oldValue, eOpts ){
        if( /[";]/.test( newValue ) ){
            me.setValidation( 'Msg contains invalid characters.'.t() );
            return false;
        }
        me.setValidation(true);
        this.getView().up('grid').getController().updateSignature( this.getViewModel().get('record'), 'msg', newValue );
    },

    sidRegex: /\s+sid:([^;]+);/,
    gidRegex: /\s+gid:\s*([^;]+);/,
    editorSidChange: function( me, newValue, oldValue, eOpts ){
        var v = this.getView();
        var vm = this.getViewModel();

        // Perform validation
        if( ! /^[0-9]+$/.test( newValue )){
            me.setValidation("Sid must be numeric".t());
            return false;
        }
        var record = vm.get('record');
        var originalRecord = v.record;

        var gid = '1';
        var signature = record.get('signature');
        if( this.gidRegex.test( signature )){
            gid = this.gidRegex.exec( signature )[1];
        }

        var match = false;
        vm.get('signatures').each( function( storeRecord ) {
            if( storeRecord != originalRecord && storeRecord.get('sid') == newValue) {
                var signatureGid = "1";
                signatureValue = storeRecord.get("signature");
                if( this.gidRegex.test( signatureValue ) ) {
                    signatureGid = this.gidRegex.exec( signatureValue )[1];
                    this.gidRegex.lastIndex = 0;
                }

                if( gid == signatureGid ){
                    match = true;
                    return false;
                }
            }
        }, this);

        if( match === true ){
            me.setValidation("Sid already in use.".t());
            return false;
        }

        me.setValidation(true);
        this.getView().up('grid').getController().updateSignature( this.getViewModel().get('record'), 'sid', newValue );
    },

    editorLogChange: function( me, newValue, oldValue, eOpts ) {
        // If log disabled, ensure that block is also disabled.
        var record = this.getViewModel().get('record');
        if( newValue === false) {
            record.set('block', false);
        }
        this.getView().up('grid').getController().updateSignature( record, 'log', newValue );
    },

    editorBlockChange: function( me, newValue, oldValue, eOpts ) {
        // If block enabled, that log is also enabled.
        var record = this.getViewModel().get('record');
        if( newValue === true ){
            record.set('log', true);
        }
        this.getView().up('grid').getController().updateSignature( record, 'block', newValue );
    },

    actionRegex: /^([#]+|)\s*(alert|log|pass|activate|dynamic|drop|sdrop|reject)/,
    editorSignatureChange: function( me, newValue, oldValue, eOpts ){
        var signature = new Ung.model.intrusionprevention.signature(newValue);

        if(!signature.get('valid')){
            return;
        }

        var record = this.getViewModel().get('record');

        record.set('sid', signature.getOption('sid'));
        record.set('gid', signature.getOption('gid'));
        record.set('msg', signature.getOption('msg'));

        var log = false;
        var block = false;
        if(signature.get('enabled')){
            var action = signature.get('action');
            if(action == 'alert'){
                log = true;
                block = false;
            }else if(action == 'drop'){
                log = true;
                block = true;
            }else if(action == 'sdrop'){
                log = false;
                block = true;
            }
        }
        record.set('log', log);
        record.set('block', block);
    }

});

Ext.define('Ung.apps.intrusionprevention.cmp.SignatureGridController', {
    extend: 'Ung.cmp.GridController',

    alias: 'controller.unintrusionsignaturesgrid',

    editorWin: function (record) {
        this.dialog = this.getView().add({
            xtype: 'ung.cmp.unintrusionsignaturesrecordeditor',
            record: record
        });
        this.dialog.show();
    },

    regexSignatureGid: /\s+gid:\s*([^;]+);/,
    sidRenderer: function( value, metaData, record, rowIdx, colIdx, store ){
        var sid = record.get('sid');
        var gid = '1';
        if( this.regexSignatureGid.test( record.get('signature') ) ){
            gid = this.regexSignatureGid.exec( record.get('signature') )[1];
        }
        metaData.tdAttr = 'data-qtip="' + Ext.String.htmlEncode( "Sid".t() + ": " + sid + ", " + "Gid".t() + ":" + gid) + '"';
        return value;
    },

    classtypeRenderer: function( value, metaData, record, rowIdx, colIdx, store ){
        var vm = this.getViewModel();
        var description = value;
        var classtypeRecord = vm.get('classtypes').findRecord('name', value);
        if( classtypeRecord != null ){
            description = classtypeRecord.get('description');
        }
        metaData.tdAttr = 'data-qtip="' + Ext.String.htmlEncode( description ) + '"';
        return value;
    },

    categoryRenderer: function( value, metaData, record, rowIdx, colIdx, store ){
        var vm = this.getViewModel();
        var description = value;
        var categoryRecord = vm.get('categories').findRecord('name', value);
        if( categoryRecord != null ){
            description = categoryRecord.get('description');
        }
        metaData.tdAttr = 'data-qtip="' + Ext.String.htmlEncode( description  ) + '"';
        return value;
    },

    regexSignatureReference: /\s+reference:\s*([^\;]+)\;/g,
    referencesMap: {
        "bugtraq": "http://www.securityfocus.com/bid/",
        "cve": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=",
        "nessus": "http://cgi.nessus.org/plugins/dump.php3?id=",
        "arachnids": "http://www.whitehats.com/info/IDS",
        "mcafee": "http://vil.nai.com/vil/content/v",
        "osvdb": "http://osvdb.org/show/osvdb/",
        "msb": "http://technet.microsoft.com/en-us/security/bulletin/",
        "url": "http://"
    },
    referenceRenderer: function( value, metaData, record, rowIdx, colIdx, store ){
        var matches = null;
        matches = value.match(this.regexSignatureReference);
        if( matches == null ){
            return "";
        }
        var references = [];
        for( var i = 0; i < matches.length; i++ ){
            var rmatches = this.regexSignatureReference.exec( matches[i] );
            this.regexSignatureReference.lastIndex = 0;

            var url = "";
            var referenceFields = rmatches[1].split(",");
            var prefix = this.referencesMap[referenceFields[0]];
            if( prefix != null ){
                referenceFields[1] = referenceFields[1].trim();
                if((referenceFields[1].charAt(0) == '"') &&
                    (referenceFields[1].charAt(referenceFields[1].length - 1) == '"')){
                    referenceFields[1] = referenceFields[1].substr(1,referenceFields[1].length - 2);
                }
                url = prefix + referenceFields[1];
                references.push('<a href="'+ url + '" class="fa fa-search fa-black" style="text-decoration: none; color:black" target="_reference"></a>');
            }
        }
        return references.join("");
    },

    logBeforeCheckChange: function ( elem, rowIndex, checked ){
        var record = elem.getView().getRecord(rowIndex);
        if( !checked){
            record.set('log', false);
            record.set('block', false );
            this.updateSignature(record, 'block', false );
            this.updateSignature(record, 'log', false );
        }else{
            record.set('log', true);
            this.updateSignature(record, 'log', true );
        }
    },

    logCheckAll: function(checkbox, checked){
        Ext.MessageBox.wait(checked ? "Checking All ...".t() : "Unchecking All ...".t(), "Please wait".t());
        Ext.Function.defer(function() {
            var grid=checkbox.up("grid");
            var records=grid.getStore().getRange();
            grid.getStore().suspendEvents(true);
            var record;
            for(var i=0; i<records.length; i++) {
                record = records[i];
                if(checked == false ) {
                    record.set('block', false);
                    this.updateSignature(records[i], 'block', checked );
                }
                record.set('log', checked);
                this.updateSignature(records[i], 'log', checked );
            }
            grid.getStore().resumeEvents();
            grid.getStore().getFilters().notify('endupdate');
            Ext.MessageBox.hide();
        }, 100, this);

    },

    blockBeforeCheckChange: function ( elem, rowIndex, checked ){
        var record = elem.getView().getRecord(rowIndex);
        if(checked) {
            record.set('log', true );
            record.set('block', true);
            this.updateSignature(record, 'log', true );
            this.updateSignature(record, 'block', true );
        }else{
            record.set('block', false);
            this.updateSignature(record, 'block', false );
        }
    },

    blockCheckAll: function(checkbox, checked){
        Ext.MessageBox.wait(checked ? "Checking All ...".t() : "Unchecking All ...".t(), "Please wait".t());
        Ext.Function.defer(function() {
            var grid=checkbox.up("grid");
            var records=grid.getStore().getRange();
            grid.getStore().suspendEvents(true);
            var record;
            for(var i=0; i<records.length; i++) {
                record = records[i];
                if(checked) {
                    record.set('log', true);
                    this.updateSignature(records[i], 'log', checked );
                }
                record.set('block', checked);
                this.updateSignature(records[i], 'block', checked );
            }
            grid.getStore().resumeEvents();
            grid.getStore().getFilters().notify('endupdate');
            Ext.MessageBox.hide();
        }, 100, this);
    },

    updateSearchStatusBar: function(){
        var v = this.getView();
        var searchStatus = v.down("[name=searchStatus]");
        var hasLogOrBlockFilter = ( v.down("[name=searchLog]").getValue() === true ) || ( v.down("[name=searchBlock]").getValue() === true );
        var hasFilter = hasLogOrBlockFilter || ( v.down("[name=searchFilter]").getValue().length >= 2 );
        var statusText = "", logOrBlockText = "", totalEnabled = 0;
        if(!hasLogOrBlockFilter) {
            v.getStore().each(function( record ){
                if( ( record.get('log')) || ( record.get('block')) ) {
                    totalEnabled++;
                }
            });
            logOrBlockText = Ext.String.format( '{0} logging or blocking'.t(), totalEnabled);
        }
        if(hasFilter) {
            statusText = Ext.String.format( '{0} matching signature(s) found'.t(), v.getStore().getCount() );
            if(!hasLogOrBlockFilter) {
                statusText += ', ' + logOrBlockText;
            }
        } else {
            statusText = Ext.String.format( '{0} available signatures'.t(), v.getStore().getCount()) + ', ' + logOrBlockText;
        }
        searchStatus.update( statusText );
    },

    searchFilter: Ext.create('Ext.util.Filter', {
        filterFn: function(){}
    }),
    filterSearch: function(elem, newValue, oldValue, eOpts){
        var store = this.getView().getStore();
        if( newValue ){
            if( newValue.length > 1 ){
                var re = new RegExp(newValue, 'gi');
                this.searchFilter.setFilterFn( function(record){
                    return re.test(record.get('category')) ||
                        re.test(record.get('signature'));
                });
                store.addFilter( this.searchFilter );
            }
        }else{
            store.removeFilter( this.searchFilter );
            if(store.filters.length === 0){
                this.getView().reconfigure();
            }
        }
        this.updateSearchStatusBar();
    },

    logFilter: Ext.create('Ext.util.Filter', {
        property: 'log',
        value: true
    }),

    filterLog: function(elem, newValue, oldValue, eOpts){
        var store = this.getView().getStore();
        if( newValue ){
            store.addFilter( this.logFilter );
        }else{
            store.removeFilter( this.logFilter );
            if(store.filters.length === 0){
                this.getView().reconfigure();
            }
        }
        this.updateSearchStatusBar();
    },

    blockFilter: Ext.create('Ext.util.Filter', {
        property: 'block',
        value: true
    }),

    filterBlock: function(elem, newValue, oldValue, eOpts){
        var store = this.getView().getStore();
        if( newValue ){
            store.addFilter( this.blockFilter );
        }else{
            store.removeFilter( this.blockFilter );
            if(store.filters.length === 0){
                this.getView().reconfigure();
            }
        }
        this.updateSearchStatusBar();
    },

    exportData: function(){
        var grid = this.getView(),
            gridName = (grid.name !== null) ? grid.name : grid.recordJavaClass,
            vm = grid.up('app-intrusion-prevention').getController().getViewModel();

        Ext.MessageBox.wait('Exporting Settings...'.t(), 'Please wait'.t());

        var downloadForm = document.getElementById('downloadForm');
        downloadForm["type"].value = "IntrusionPreventionSettings";
        downloadForm["arg1"].value = "export";
        downloadForm["arg2"].value = vm.get('instance.id');
        downloadForm["arg3"].value = gridName.trim().replace(/ /g, '_');
        downloadForm["arg4"].value = Ext.encode({signatures: grid.up('app-intrusion-prevention').getController().getChangedDataRecords('signatures')});
        downloadForm.submit();

        Ext.MessageBox.hide();
    },

    importHandler: function(importMode, newData){
        var me = this;

        this.callParent(arguments);
        var store = this.getView().getStore();

        store.each( function(record){
            me.updateSignature(record, 'log', record.get('log') );
            me.updateSignature(record, 'block', record.get('block') );

        });
    },

    signaturesReconfigure: function( me , store , columns , oldStore , oldColumns , eOpts ){
        me.getController().updateSearchStatusBar();
    },

    updateSignature: function( record, updatedKey, updatedValue){
        var i, regex;
        var signatureValue = record.get('signature');
        var updatedSubkey = null;

        var signature = new Ung.model.intrusionprevention.signature(signatureValue);
        if(!signature.get('valid')){
            return;
        }

        // Action replacement
        if(updatedKey == 'log' || updatedKey == 'block'){
            var logValue = record.get('log');
            var blockValue = record.get('block');
            if(updatedKey == 'log'){
                logValue = updatedValue;
            }
            if(updatedKey == 'block'){
                blockValue = updatedValue;
            }

            signature.set('action', 'alert');
            signature.set('enabled', true);
            if( logValue === true && blockValue === true ) {
                signature.set('action', 'drop');
            } else if( logValue === false && blockValue === true ) {
                signature.set('action', 'sdrop');
            }else if( logValue === false && blockValue === false ) {
                signature.set('enabled', false);
            }

            // Update metadata with indicator that user has changed to preserve on signature updates.
            var date = new Date(Date.now() + Renderer.timestampOffset);
            signature.setMetadataOption('untangle_action', Ext.util.Format.date(date, "Y_m_d"));
        }else{
            signature.setOption(updatedKey, updatedValue);
        }
        record.set('signature', signature.build());
    }

});

Ext.define('Ung.apps.intrusionprevention.cmp.VariablesRecordEditor', {
    extend: 'Ung.cmp.RecordEditor',
    xtype: 'ung.cmp.unintrusionvariablesrecordeditor',

    controller: 'unintrusionvariablesrecordeditorcontroller',
});

Ext.define('Ung.apps.intrusionprevention.cmp.VariablesRecordEditorController', {
    extend: 'Ung.cmp.RecordEditorController',
    alias: 'controller.unintrusionvariablesrecordeditorcontroller',

    editorVariableChange: function( me, newValue, oldValue, eOpts ){
        var v = this.getView();
        var vm = this.getViewModel();

        var match = false;
        vm.get('variables').each( function( storeRecord ) {
            if( ( storeRecord !== v.record ) && ( newValue == storeRecord.get('variable') ) ){
                match = true;
            }
        });
        if(match){
            me.setValidation("Variable name already in use.".t());
            return false;

        }
        me.setValidation(true);

        var activeVariable = v.up('app-intrusion-prevention').getController().isVariableUsed(newValue);
        me.setReadOnly(activeVariable);
        me.up("").down("[name=activeVariable]").setVisible(activeVariable);
    }

});

Ext.define('Ung.apps.intrusionprevention.cmp.VariablesGridController', {
    extend: 'Ung.cmp.GridController',

    alias: 'controller.unintrusionvariablesgrid',

    editorWin: function (record) {
        this.dialog = this.getView().add({
            xtype: 'ung.cmp.unintrusionvariablesrecordeditor',
            record: record
        });
        this.dialog.show();
    },

    exportData: function(){
        var grid = this.getView(),
            gridName = (grid.name !== null) ? grid.name : grid.recordJavaClass,
            vm = grid.up('app-intrusion-prevention').getController().getViewModel();

        Ext.MessageBox.wait('Exporting Settings...'.t(), 'Please wait'.t());

        var downloadForm = document.getElementById('downloadForm');
        downloadForm["type"].value = "IntrusionPreventionSettings";
        downloadForm["arg1"].value = "export";
        downloadForm["arg2"].value = vm.get('instance.id');
        downloadForm["arg3"].value = gridName.trim().replace(/ /g, '_');
        downloadForm["arg4"].value = Ext.encode({variables: grid.up('app-intrusion-prevention').getController().getChangedDataRecords('variables')});
        downloadForm.submit();

        Ext.MessageBox.hide();
    },

    deleteRecord: function (view, rowIndex, colIndex, item, e, record) {
        if( this.getView().up('app-intrusion-prevention').getController().isVariableUsed( record.get('variable') ) ){
            Ext.MessageBox.alert( "Cannot Delete Variable".t(), "Variable is used by one or more signatures.".t() );
        }else{
            if (record.get('markedForNew')) {
                record.drop();
            } else {
                record.set('markedForDelete', true);
            }
        }
    }
});

Ext.define('Ung.model.intrusionprevention.signature',{
    extend: 'Ext.data.Model',
    fields:[{
        name: 'valid',
        type: 'boolean'
    },{
        name: 'enabled',
        type: 'boolean'
    },{
        name: 'action',
        type: 'string',
        defaultValue: 'alert'
    },{
        name: 'protocol',
        type: 'string'
    },{
        name: 'lnet',
        type: 'string'
    },{
        name: 'lport',
        type: 'string'
    },{
        name: 'direction',
        type: 'string'
    },{
        name: 'rnet',
        type: 'string'
    },{
        name: 'rport',
        type: 'string'
    },{
        name: 'options'
    },{
        name: 'optionsMetadata'
    }],

    signatureRegexMatch: /^([#\s]+|)(alert|log|pass|activate|dynamic|drop|reject|sdrop)\s+((tcp|udp|icmp|ip)\s+([^\s]+)\s+([^\s]+)\s+(\-\>|<>)\s+([^\s]+)\s+([^\s]+)\s+|)\((.+)\)/,
    constructor: function(signature, session){
        var data = {
            valid: true,
            enabled: false,
            action: 'alert',
            protocol: '',
            lnet: '',
            lport: '',
            direction: '',
            rnet: '',
            rport: '',
            options: [],
            metadataOptions: []
        };

        if(!this.signatureRegexMatch.test(signature)){
            data['valid'] = false;
        }else{
            var matches = this.signatureRegexMatch.exec(signature);

            data['enabled'] = matches[1] == '#' ? false : true;
            data['action'] = matches[2].toLowerCase();
            if(matches[3] != ""){
                data['protocol'] = matches[4].toLowerCase();
                data['lnet'] = matches[5];
                data['lport'] = matches[6];
                data['direction'] = matches[7];
                data['rnet'] = matches[8];
                data['rport'] = matches[9];
            }
            data['options'] = matches[10].trim().split(';');
            data['options'].forEach( function(option, index, options){
                options[index] = option.trim();
                var kv = option.trim().split(':');
                if(kv[0] == 'metadata'){
                    data['optionsMetadata'] = kv[1].trim().split(',');
                    data['optionsMetadata'].forEach( function( moption, mindex, moptions){
                        moptions[mindex] = moption.trim();
                    });
                }
            });
        }

        this.callParent([data], session);
    },

    getOption: function(key){
        value = null;

        var options = this.get('options');
        var kv;
        options.forEach( function( option, index, optionsMetadata){
            kv = option.split(':');
            if(kv[0].trim() == key){
                kv[1] = kv[1].trim();
                if(kv[1][0] == '"' && kv[1][kv[1].length -1] == '"'){
                    kv[1] = kv[1].substring(1,kv[1].length - 1);
                }
                value = kv[1];
            }
        });
        return value;
    },

    setOption: function( key, value){
        var options = this.get('options');
        var found = false;
        var kv;
        options.forEach( function( option, index, optionsMetadata){
            kv = option.split(':');
            if(kv[0].trim() == key){
                kv[1] = kv[1].trim();
                var preserveQuotes = false;
                if(kv[1][0] == '"' && kv[1][kv[1].length -1] == '"'){
                    preserveQuotes = true;
                }
                kv[1] = (preserveQuotes ? '"' : '' ) + value + (preserveQuotes ? '"' : '' );
                found = true;
                options[index] = kv.join(': ');
            }
        });
        if(!found){
            options.push(key + ': ' + value);
        }
        this.set('options', options);
    },

    setMetadataOption: function( key, value){
        var optionsMetadata = this.get('optionsMetadata');
        if(optionsMetadata === undefined){
            optionsMetadata = [];
        }
        var found = false;
        var kv;
        optionsMetadata.forEach( function( option, index, optionsMetadata){
            kv = option.split(' ');
            if(kv[0].trim() == key){
                kv[1] = value;
                found = true;
                optionsMetadata[index] = kv.join(' ');
            }
        });
        if(!found){
            optionsMetadata.push(key + ' ' + value);
        }
        this.set('optionsMetadata', optionsMetadata);
    },

    build: function(){

        var options = this.get('options');
        var metadataOptions = this.get('optionsMetadata');
        if(metadataOptions){
            metadataOptions = metadataOptions.join(', ');
            var metadataFound = false;
            options.forEach( function(option, index, options){
                var kv = option.split(':');
                if(kv[0].trim() == 'metadata'){
                    kv[1] = metadataOptions;
                    options[index] = kv.join(': ');
                    metadataFound = true;
                }
            });
            if(!metadataFound){
                options.push('metadata: ' + metadataOptions);
            }
        }
        options = options.join('; ');

        return (this.get('enabled')  ? '' : '#') +
            this.get('action') + " " +
            (this.get('protocol') ? this.get('protocol') + ' ' : '') +
            (this.get('lnet') ? this.get('lnet') + ' ' : '') +
            (this.get('lport') ? this.get('lport') + ' ' : '') +
            (this.get('direction') ? this.get('direction') + ' ' : '') +
            (this.get('rnet') ? this.get('rnet') + ' ' : '') +
            (this.get('rport') ? this.get('rport') + ' ' : '') +
            "( " + options + " )";
    }
});